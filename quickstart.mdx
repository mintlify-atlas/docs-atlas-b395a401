---
title: Quick start
description: Get started with Privacy Cash in minutes
---

## Overview

This guide will help you get Privacy Cash running quickly. You'll learn how to build the program, run tests, and execute your first private transaction.

<Note>
  For production use, we recommend using the [Privacy Cash SDK](https://github.com/Privacy-Cash/privacy-cash-sdk) instead of building from source.
</Note>

## Prerequisites

Before you begin, ensure you have:

<CardGroup cols={2}>
  <Card title="Solana CLI" icon="terminal">
    Version 2.1.18 or later
  </Card>
  <Card title="Rust" icon="rust">
    Version 1.79.0 or compatible
  </Card>
  <Card title="Anchor" icon="anchor">
    Version 0.31.1
  </Card>
  <Card title="Node.js" icon="node">
    Version 16 or later
  </Card>
</CardGroup>

<Info>
  See the [installation guide](/installation) for detailed setup instructions.
</Info>

## Build the program

<Steps>
  <Step title="Clone the repository">
    ```bash
    git clone https://github.com/Privacy-Cash/privacy-cash.git
    cd privacy-cash
    ```
  </Step>

  <Step title="Navigate to the program directory">
    ```bash
    cd anchor
    ```
  </Step>

  <Step title="Build the Anchor program">
    ```bash
    anchor build
    ```

    This compiles the Solana program and generates the IDL (Interface Definition Language) file.
  </Step>

  <Step title="Verify the build">
    Check that the compiled program exists:

    ```bash
    ls target/deploy/zkcash.so
    ```

    You should see the compiled program artifact.
  </Step>
</Steps>

## Run tests

Privacy Cash includes comprehensive test suites for SOL and SPL token transactions.

<Tabs>
  <Tab title="SOL tests">
    Test native SOL private transactions:

    ```bash
    npm run test:sol
    ```

    This runs the test suite at `tests/sol_tests.ts` which includes:
    - Double spend attack prevention
    - Deposit and withdrawal with fees
    - PDA recipient support
    - Nullifier verification
  </Tab>

  <Tab title="SPL tests">
    Test SPL token private transactions:

    ```bash
    npm run test:spl
    ```

    This runs the test suite at `tests/spl_tests.ts` for SPL token deposits and withdrawals.
  </Tab>

  <Tab title="Mint checked tests">
    Test mint-checked SPL token transactions:

    ```bash
    npm run test:mint-checked
    ```

    This runs the test suite at `tests/spl_mint_test.ts` with additional mint validation.
  </Tab>

  <Tab title="Unit tests">
    Run Rust unit tests:

    ```bash
    cargo test
    ```

    This executes the Rust-level unit tests for the program logic.
  </Tab>
</Tabs>

<Note>
  The integration tests use the `localnet` feature flag and spin up a local Solana validator automatically.
</Note>

## Understanding a private transaction

Here's a breakdown of how Privacy Cash transactions work using code from the test suite:

<Steps>
  <Step title="Create UTXOs">
    For a deposit, create two output UTXOs (one with your amount, one empty):

    ```typescript
    const depositAmount = 20000;
    const calculatedDepositFee = calculateDepositFee(depositAmount); // 0 for deposits

    const inputs = [
      new Utxo({ lightWasm }),  // Empty input
      new Utxo({ lightWasm })   // Empty input
    ];

    const outputAmount = (depositAmount - calculatedDepositFee).toString();
    const outputs = [
      new Utxo({ 
        lightWasm, 
        amount: outputAmount, 
        index: globalMerkleTree._layers[0].length 
      }),
      new Utxo({ lightWasm, amount: '0' })
    ];
    ```
  </Step>

  <Step title="Generate the zero-knowledge proof">
    Create the proof input and generate the proof:

    ```typescript
    const inputNullifiers = await Promise.all(inputs.map(x => x.getNullifier()));
    const outputCommitments = await Promise.all(outputs.map(x => x.getCommitment()));
    const root = globalMerkleTree.root();
    const extDataHash = getExtDataHash(extData);

    const input = {
      root: root,
      inputNullifier: inputNullifiers,
      outputCommitment: outputCommitments,
      publicAmount: publicAmountNumber.toString(),
      extDataHash: extDataHash,
      inAmount: inputs.map(x => x.amount.toString(10)),
      inPrivateKey: inputs.map(x => x.keypair.privkey),
      inBlinding: inputs.map(x => x.blinding.toString(10)),
      mintAddress: inputs[0].mintAddress,
      inPathIndices: inputMerklePathIndices,
      inPathElements: inputMerklePathElements,
      outAmount: outputs.map(x => x.amount.toString(10)),
      outBlinding: outputs.map(x => x.blinding.toString(10)),
      outPubkey: outputs.map(x => x.keypair.pubkey),
    };

    const keyBasePath = path.resolve(__dirname, '../../artifacts/circuits/transaction2');
    const {proof, publicSignals} = await prove(input, keyBasePath);
    ```
  </Step>

  <Step title="Submit the transaction">
    Format the proof and submit to the program:

    ```typescript
    const proofInBytes = parseProofToBytesArray(proof);
    const inputsInBytes = parseToBytesArray(publicSignals);
    
    const proofToSubmit = {
      proofA: proofInBytes.proofA,
      proofB: proofInBytes.proofB.flat(),
      proofC: proofInBytes.proofC,
      root: inputsInBytes[0],
      publicAmount: inputsInBytes[1],
      extDataHash: inputsInBytes[2],
      inputNullifiers: [inputsInBytes[3], inputsInBytes[4]],
      outputCommitments: [inputsInBytes[5], inputsInBytes[6]],
    };

    await program.methods
      .transact(
        proofToSubmit, 
        createExtDataMinified(extData), 
        extData.encryptedOutput1, 
        extData.encryptedOutput2
      )
      .accounts({
        treeAccount: treeAccountPDA,
        nullifier0: nullifier0PDA,
        nullifier1: nullifier1PDA,
        nullifier2: nullifier2PDA,
        nullifier3: nullifier3PDA,
        recipient: recipient.publicKey,
        feeRecipientAccount: FEE_RECIPIENT_ACCOUNT,
        treeTokenAccount: treeTokenAccountPDA,
        globalConfig: globalConfigPDA,
        signer: randomUser.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId
      })
      .signers([randomUser])
      .rpc();
    ```
  </Step>
</Steps>

<Warning>
  The zero-knowledge proof generation is computationally intensive. On a typical laptop, proof generation takes 5-15 seconds.
</Warning>

## Deploy to devnet

Once you've tested locally, deploy to Solana devnet:

<Steps>
  <Step title="Build with devnet feature">
    ```bash
    anchor build -- --features devnet
    ```
  </Step>

  <Step title="Prepare the program keypair">
    ```bash
    rm target/deploy/zkcash-keypair.json
    cp zkcash-keypair.json target/deploy/zkcash-keypair.json
    ```
  </Step>

  <Step title="Deploy to devnet">
    ```bash
    anchor deploy --provider.cluster devnet
    ```

    Or use the verifiable build:

    ```bash
    anchor deploy --verifiable --provider.cluster devnet
    ```
  </Step>
</Steps>

<Info>
  Verifiable builds allow anyone to verify that the deployed program matches the source code. This is important for security and trust.
</Info>

## Next steps

<CardGroup cols={2}>
  <Card
    title="Installation guide"
    icon="download"
    href="/installation"
  >
    Detailed setup instructions for all dependencies
  </Card>
  <Card
    title="Privacy Cash SDK"
    icon="code"
    href="https://github.com/Privacy-Cash/privacy-cash-sdk"
  >
    Integrate Privacy Cash into your application
  </Card>
  <Card
    title="Program source code"
    icon="file-code"
    href="https://github.com/Privacy-Cash/privacy-cash/tree/main/anchor/programs/zkcash/src"
  >
    Explore the Rust implementation
  </Card>
  <Card
    title="Test suites"
    icon="flask"
    href="https://github.com/Privacy-Cash/privacy-cash/tree/main/anchor/tests"
  >
    Review comprehensive test examples
  </Card>
</CardGroup>
